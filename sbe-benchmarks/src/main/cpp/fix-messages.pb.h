// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: fix-messages.proto

#ifndef PROTOBUF_INCLUDED_fix_2dmessages_2eproto
#define PROTOBUF_INCLUDED_fix_2dmessages_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_fix_2dmessages_2eproto 

namespace protobuf_fix_2dmessages_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[3];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_fix_2dmessages_2eproto
namespace Fix {
class Decimal64;
class Decimal64DefaultTypeInternal;
extern Decimal64DefaultTypeInternal _Decimal64_default_instance_;
class IntQty32;
class IntQty32DefaultTypeInternal;
extern IntQty32DefaultTypeInternal _IntQty32_default_instance_;
class NewOrderSingle;
class NewOrderSingleDefaultTypeInternal;
extern NewOrderSingleDefaultTypeInternal _NewOrderSingle_default_instance_;
}  // namespace Fix
namespace google {
namespace protobuf {
template<> ::Fix::Decimal64* Arena::CreateMaybeMessage<::Fix::Decimal64>(Arena*);
template<> ::Fix::IntQty32* Arena::CreateMaybeMessage<::Fix::IntQty32>(Arena*);
template<> ::Fix::NewOrderSingle* Arena::CreateMaybeMessage<::Fix::NewOrderSingle>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace Fix {

enum NewOrderSingle_OrdType {
  NewOrderSingle_OrdType_NONE = 0,
  NewOrderSingle_OrdType_MARKET_ORDER = 1,
  NewOrderSingle_OrdType_LIMIT_ORDER = 2,
  NewOrderSingle_OrdType_STOP_ORDER = 3,
  NewOrderSingle_OrdType_STOP_LIMIT_ORDER = 4,
  NewOrderSingle_OrdType_NewOrderSingle_OrdType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  NewOrderSingle_OrdType_NewOrderSingle_OrdType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool NewOrderSingle_OrdType_IsValid(int value);
const NewOrderSingle_OrdType NewOrderSingle_OrdType_OrdType_MIN = NewOrderSingle_OrdType_NONE;
const NewOrderSingle_OrdType NewOrderSingle_OrdType_OrdType_MAX = NewOrderSingle_OrdType_STOP_LIMIT_ORDER;
const int NewOrderSingle_OrdType_OrdType_ARRAYSIZE = NewOrderSingle_OrdType_OrdType_MAX + 1;

const ::google::protobuf::EnumDescriptor* NewOrderSingle_OrdType_descriptor();
inline const ::std::string& NewOrderSingle_OrdType_Name(NewOrderSingle_OrdType value) {
  return ::google::protobuf::internal::NameOfEnum(
    NewOrderSingle_OrdType_descriptor(), value);
}
inline bool NewOrderSingle_OrdType_Parse(
    const ::std::string& name, NewOrderSingle_OrdType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NewOrderSingle_OrdType>(
    NewOrderSingle_OrdType_descriptor(), name, value);
}
enum NewOrderSingle_TimeInForce {
  NewOrderSingle_TimeInForce_DAY = 0,
  NewOrderSingle_TimeInForce_GOOD_TILL_CANCEL = 1,
  NewOrderSingle_TimeInForce_FILL_AND_KILL = 3,
  NewOrderSingle_TimeInForce_GOOD_TILL_DATE = 6,
  NewOrderSingle_TimeInForce_NewOrderSingle_TimeInForce_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  NewOrderSingle_TimeInForce_NewOrderSingle_TimeInForce_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool NewOrderSingle_TimeInForce_IsValid(int value);
const NewOrderSingle_TimeInForce NewOrderSingle_TimeInForce_TimeInForce_MIN = NewOrderSingle_TimeInForce_DAY;
const NewOrderSingle_TimeInForce NewOrderSingle_TimeInForce_TimeInForce_MAX = NewOrderSingle_TimeInForce_GOOD_TILL_DATE;
const int NewOrderSingle_TimeInForce_TimeInForce_ARRAYSIZE = NewOrderSingle_TimeInForce_TimeInForce_MAX + 1;

const ::google::protobuf::EnumDescriptor* NewOrderSingle_TimeInForce_descriptor();
inline const ::std::string& NewOrderSingle_TimeInForce_Name(NewOrderSingle_TimeInForce value) {
  return ::google::protobuf::internal::NameOfEnum(
    NewOrderSingle_TimeInForce_descriptor(), value);
}
inline bool NewOrderSingle_TimeInForce_Parse(
    const ::std::string& name, NewOrderSingle_TimeInForce* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NewOrderSingle_TimeInForce>(
    NewOrderSingle_TimeInForce_descriptor(), name, value);
}
enum NewOrderSingle_Side {
  NewOrderSingle_Side_SIDE_NONE = 0,
  NewOrderSingle_Side_BUY = 1,
  NewOrderSingle_Side_SELL = 2,
  NewOrderSingle_Side_NewOrderSingle_Side_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  NewOrderSingle_Side_NewOrderSingle_Side_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool NewOrderSingle_Side_IsValid(int value);
const NewOrderSingle_Side NewOrderSingle_Side_Side_MIN = NewOrderSingle_Side_SIDE_NONE;
const NewOrderSingle_Side NewOrderSingle_Side_Side_MAX = NewOrderSingle_Side_SELL;
const int NewOrderSingle_Side_Side_ARRAYSIZE = NewOrderSingle_Side_Side_MAX + 1;

const ::google::protobuf::EnumDescriptor* NewOrderSingle_Side_descriptor();
inline const ::std::string& NewOrderSingle_Side_Name(NewOrderSingle_Side value) {
  return ::google::protobuf::internal::NameOfEnum(
    NewOrderSingle_Side_descriptor(), value);
}
inline bool NewOrderSingle_Side_Parse(
    const ::std::string& name, NewOrderSingle_Side* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NewOrderSingle_Side>(
    NewOrderSingle_Side_descriptor(), name, value);
}
enum NewOrderSingle_HandInst {
  NewOrderSingle_HandInst_HANDINST_NONE = 0,
  NewOrderSingle_HandInst_AUTOMATIC = 1,
  NewOrderSingle_HandInst_NewOrderSingle_HandInst_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  NewOrderSingle_HandInst_NewOrderSingle_HandInst_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool NewOrderSingle_HandInst_IsValid(int value);
const NewOrderSingle_HandInst NewOrderSingle_HandInst_HandInst_MIN = NewOrderSingle_HandInst_HANDINST_NONE;
const NewOrderSingle_HandInst NewOrderSingle_HandInst_HandInst_MAX = NewOrderSingle_HandInst_AUTOMATIC;
const int NewOrderSingle_HandInst_HandInst_ARRAYSIZE = NewOrderSingle_HandInst_HandInst_MAX + 1;

const ::google::protobuf::EnumDescriptor* NewOrderSingle_HandInst_descriptor();
inline const ::std::string& NewOrderSingle_HandInst_Name(NewOrderSingle_HandInst value) {
  return ::google::protobuf::internal::NameOfEnum(
    NewOrderSingle_HandInst_descriptor(), value);
}
inline bool NewOrderSingle_HandInst_Parse(
    const ::std::string& name, NewOrderSingle_HandInst* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NewOrderSingle_HandInst>(
    NewOrderSingle_HandInst_descriptor(), name, value);
}
// ===================================================================

class Decimal64 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Fix.Decimal64) */ {
 public:
  Decimal64();
  virtual ~Decimal64();

  Decimal64(const Decimal64& from);

  inline Decimal64& operator=(const Decimal64& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Decimal64(Decimal64&& from) noexcept
    : Decimal64() {
    *this = ::std::move(from);
  }

  inline Decimal64& operator=(Decimal64&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Decimal64& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Decimal64* internal_default_instance() {
    return reinterpret_cast<const Decimal64*>(
               &_Decimal64_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Decimal64* other);
  friend void swap(Decimal64& a, Decimal64& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Decimal64* New() const final {
    return CreateMaybeMessage<Decimal64>(NULL);
  }

  Decimal64* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Decimal64>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Decimal64& from);
  void MergeFrom(const Decimal64& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Decimal64* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 mantissa = 1;
  void clear_mantissa();
  static const int kMantissaFieldNumber = 1;
  ::google::protobuf::int64 mantissa() const;
  void set_mantissa(::google::protobuf::int64 value);

  // uint32 exponent = 2;
  void clear_exponent();
  static const int kExponentFieldNumber = 2;
  ::google::protobuf::uint32 exponent() const;
  void set_exponent(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Fix.Decimal64)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 mantissa_;
  ::google::protobuf::uint32 exponent_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_fix_2dmessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IntQty32 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Fix.IntQty32) */ {
 public:
  IntQty32();
  virtual ~IntQty32();

  IntQty32(const IntQty32& from);

  inline IntQty32& operator=(const IntQty32& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IntQty32(IntQty32&& from) noexcept
    : IntQty32() {
    *this = ::std::move(from);
  }

  inline IntQty32& operator=(IntQty32&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const IntQty32& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IntQty32* internal_default_instance() {
    return reinterpret_cast<const IntQty32*>(
               &_IntQty32_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(IntQty32* other);
  friend void swap(IntQty32& a, IntQty32& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IntQty32* New() const final {
    return CreateMaybeMessage<IntQty32>(NULL);
  }

  IntQty32* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IntQty32>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IntQty32& from);
  void MergeFrom(const IntQty32& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntQty32* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 mantissa = 1;
  void clear_mantissa();
  static const int kMantissaFieldNumber = 1;
  ::google::protobuf::int32 mantissa() const;
  void set_mantissa(::google::protobuf::int32 value);

  // uint32 exponent = 2;
  void clear_exponent();
  static const int kExponentFieldNumber = 2;
  ::google::protobuf::uint32 exponent() const;
  void set_exponent(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Fix.IntQty32)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 mantissa_;
  ::google::protobuf::uint32 exponent_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_fix_2dmessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NewOrderSingle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Fix.NewOrderSingle) */ {
 public:
  NewOrderSingle();
  virtual ~NewOrderSingle();

  NewOrderSingle(const NewOrderSingle& from);

  inline NewOrderSingle& operator=(const NewOrderSingle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NewOrderSingle(NewOrderSingle&& from) noexcept
    : NewOrderSingle() {
    *this = ::std::move(from);
  }

  inline NewOrderSingle& operator=(NewOrderSingle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NewOrderSingle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NewOrderSingle* internal_default_instance() {
    return reinterpret_cast<const NewOrderSingle*>(
               &_NewOrderSingle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(NewOrderSingle* other);
  friend void swap(NewOrderSingle& a, NewOrderSingle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NewOrderSingle* New() const final {
    return CreateMaybeMessage<NewOrderSingle>(NULL);
  }

  NewOrderSingle* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NewOrderSingle>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NewOrderSingle& from);
  void MergeFrom(const NewOrderSingle& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewOrderSingle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef NewOrderSingle_OrdType OrdType;
  static const OrdType NONE =
    NewOrderSingle_OrdType_NONE;
  static const OrdType MARKET_ORDER =
    NewOrderSingle_OrdType_MARKET_ORDER;
  static const OrdType LIMIT_ORDER =
    NewOrderSingle_OrdType_LIMIT_ORDER;
  static const OrdType STOP_ORDER =
    NewOrderSingle_OrdType_STOP_ORDER;
  static const OrdType STOP_LIMIT_ORDER =
    NewOrderSingle_OrdType_STOP_LIMIT_ORDER;
  static inline bool OrdType_IsValid(int value) {
    return NewOrderSingle_OrdType_IsValid(value);
  }
  static const OrdType OrdType_MIN =
    NewOrderSingle_OrdType_OrdType_MIN;
  static const OrdType OrdType_MAX =
    NewOrderSingle_OrdType_OrdType_MAX;
  static const int OrdType_ARRAYSIZE =
    NewOrderSingle_OrdType_OrdType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OrdType_descriptor() {
    return NewOrderSingle_OrdType_descriptor();
  }
  static inline const ::std::string& OrdType_Name(OrdType value) {
    return NewOrderSingle_OrdType_Name(value);
  }
  static inline bool OrdType_Parse(const ::std::string& name,
      OrdType* value) {
    return NewOrderSingle_OrdType_Parse(name, value);
  }

  typedef NewOrderSingle_TimeInForce TimeInForce;
  static const TimeInForce DAY =
    NewOrderSingle_TimeInForce_DAY;
  static const TimeInForce GOOD_TILL_CANCEL =
    NewOrderSingle_TimeInForce_GOOD_TILL_CANCEL;
  static const TimeInForce FILL_AND_KILL =
    NewOrderSingle_TimeInForce_FILL_AND_KILL;
  static const TimeInForce GOOD_TILL_DATE =
    NewOrderSingle_TimeInForce_GOOD_TILL_DATE;
  static inline bool TimeInForce_IsValid(int value) {
    return NewOrderSingle_TimeInForce_IsValid(value);
  }
  static const TimeInForce TimeInForce_MIN =
    NewOrderSingle_TimeInForce_TimeInForce_MIN;
  static const TimeInForce TimeInForce_MAX =
    NewOrderSingle_TimeInForce_TimeInForce_MAX;
  static const int TimeInForce_ARRAYSIZE =
    NewOrderSingle_TimeInForce_TimeInForce_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TimeInForce_descriptor() {
    return NewOrderSingle_TimeInForce_descriptor();
  }
  static inline const ::std::string& TimeInForce_Name(TimeInForce value) {
    return NewOrderSingle_TimeInForce_Name(value);
  }
  static inline bool TimeInForce_Parse(const ::std::string& name,
      TimeInForce* value) {
    return NewOrderSingle_TimeInForce_Parse(name, value);
  }

  typedef NewOrderSingle_Side Side;
  static const Side SIDE_NONE =
    NewOrderSingle_Side_SIDE_NONE;
  static const Side BUY =
    NewOrderSingle_Side_BUY;
  static const Side SELL =
    NewOrderSingle_Side_SELL;
  static inline bool Side_IsValid(int value) {
    return NewOrderSingle_Side_IsValid(value);
  }
  static const Side Side_MIN =
    NewOrderSingle_Side_Side_MIN;
  static const Side Side_MAX =
    NewOrderSingle_Side_Side_MAX;
  static const int Side_ARRAYSIZE =
    NewOrderSingle_Side_Side_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Side_descriptor() {
    return NewOrderSingle_Side_descriptor();
  }
  static inline const ::std::string& Side_Name(Side value) {
    return NewOrderSingle_Side_Name(value);
  }
  static inline bool Side_Parse(const ::std::string& name,
      Side* value) {
    return NewOrderSingle_Side_Parse(name, value);
  }

  typedef NewOrderSingle_HandInst HandInst;
  static const HandInst HANDINST_NONE =
    NewOrderSingle_HandInst_HANDINST_NONE;
  static const HandInst AUTOMATIC =
    NewOrderSingle_HandInst_AUTOMATIC;
  static inline bool HandInst_IsValid(int value) {
    return NewOrderSingle_HandInst_IsValid(value);
  }
  static const HandInst HandInst_MIN =
    NewOrderSingle_HandInst_HandInst_MIN;
  static const HandInst HandInst_MAX =
    NewOrderSingle_HandInst_HandInst_MAX;
  static const int HandInst_ARRAYSIZE =
    NewOrderSingle_HandInst_HandInst_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  HandInst_descriptor() {
    return NewOrderSingle_HandInst_descriptor();
  }
  static inline const ::std::string& HandInst_Name(HandInst value) {
    return NewOrderSingle_HandInst_Name(value);
  }
  static inline bool HandInst_Parse(const ::std::string& name,
      HandInst* value) {
    return NewOrderSingle_HandInst_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // bytes symbol = 8;
  void clear_symbol();
  static const int kSymbolFieldNumber = 8;
  const ::std::string& symbol() const;
  void set_symbol(const ::std::string& value);
  #if LANG_CXX11
  void set_symbol(::std::string&& value);
  #endif
  void set_symbol(const char* value);
  void set_symbol(const void* value, size_t size);
  ::std::string* mutable_symbol();
  ::std::string* release_symbol();
  void set_allocated_symbol(::std::string* symbol);

  // bytes account = 9;
  void clear_account();
  static const int kAccountFieldNumber = 9;
  const ::std::string& account() const;
  void set_account(const ::std::string& value);
  #if LANG_CXX11
  void set_account(::std::string&& value);
  #endif
  void set_account(const char* value);
  void set_account(const void* value, size_t size);
  ::std::string* mutable_account();
  ::std::string* release_account();
  void set_allocated_account(::std::string* account);

  // bytes clOrdID = 10;
  void clear_clordid();
  static const int kClOrdIDFieldNumber = 10;
  const ::std::string& clordid() const;
  void set_clordid(const ::std::string& value);
  #if LANG_CXX11
  void set_clordid(::std::string&& value);
  #endif
  void set_clordid(const char* value);
  void set_clordid(const void* value, size_t size);
  ::std::string* mutable_clordid();
  ::std::string* release_clordid();
  void set_allocated_clordid(::std::string* clordid);

  // .Fix.IntQty32 orderQty = 2;
  bool has_orderqty() const;
  void clear_orderqty();
  static const int kOrderQtyFieldNumber = 2;
  private:
  const ::Fix::IntQty32& _internal_orderqty() const;
  public:
  const ::Fix::IntQty32& orderqty() const;
  ::Fix::IntQty32* release_orderqty();
  ::Fix::IntQty32* mutable_orderqty();
  void set_allocated_orderqty(::Fix::IntQty32* orderqty);

  // .Fix.Decimal64 price = 4;
  bool has_price() const;
  void clear_price();
  static const int kPriceFieldNumber = 4;
  private:
  const ::Fix::Decimal64& _internal_price() const;
  public:
  const ::Fix::Decimal64& price() const;
  ::Fix::Decimal64* release_price();
  ::Fix::Decimal64* mutable_price();
  void set_allocated_price(::Fix::Decimal64* price);

  // uint64 transactTime = 1;
  void clear_transacttime();
  static const int kTransactTimeFieldNumber = 1;
  ::google::protobuf::uint64 transacttime() const;
  void set_transacttime(::google::protobuf::uint64 value);

  // .Fix.NewOrderSingle.OrdType ordType = 3;
  void clear_ordtype();
  static const int kOrdTypeFieldNumber = 3;
  ::Fix::NewOrderSingle_OrdType ordtype() const;
  void set_ordtype(::Fix::NewOrderSingle_OrdType value);

  // .Fix.NewOrderSingle.Side side = 5;
  void clear_side();
  static const int kSideFieldNumber = 5;
  ::Fix::NewOrderSingle_Side side() const;
  void set_side(::Fix::NewOrderSingle_Side value);

  // .Fix.NewOrderSingle.TimeInForce tif = 6;
  void clear_tif();
  static const int kTifFieldNumber = 6;
  ::Fix::NewOrderSingle_TimeInForce tif() const;
  void set_tif(::Fix::NewOrderSingle_TimeInForce value);

  // .Fix.NewOrderSingle.HandInst handInst = 7;
  void clear_handinst();
  static const int kHandInstFieldNumber = 7;
  ::Fix::NewOrderSingle_HandInst handinst() const;
  void set_handinst(::Fix::NewOrderSingle_HandInst value);

  // @@protoc_insertion_point(class_scope:Fix.NewOrderSingle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr symbol_;
  ::google::protobuf::internal::ArenaStringPtr account_;
  ::google::protobuf::internal::ArenaStringPtr clordid_;
  ::Fix::IntQty32* orderqty_;
  ::Fix::Decimal64* price_;
  ::google::protobuf::uint64 transacttime_;
  int ordtype_;
  int side_;
  int tif_;
  int handinst_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_fix_2dmessages_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Decimal64

// int64 mantissa = 1;
inline void Decimal64::clear_mantissa() {
  mantissa_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Decimal64::mantissa() const {
  // @@protoc_insertion_point(field_get:Fix.Decimal64.mantissa)
  return mantissa_;
}
inline void Decimal64::set_mantissa(::google::protobuf::int64 value) {
  
  mantissa_ = value;
  // @@protoc_insertion_point(field_set:Fix.Decimal64.mantissa)
}

// uint32 exponent = 2;
inline void Decimal64::clear_exponent() {
  exponent_ = 0u;
}
inline ::google::protobuf::uint32 Decimal64::exponent() const {
  // @@protoc_insertion_point(field_get:Fix.Decimal64.exponent)
  return exponent_;
}
inline void Decimal64::set_exponent(::google::protobuf::uint32 value) {
  
  exponent_ = value;
  // @@protoc_insertion_point(field_set:Fix.Decimal64.exponent)
}

// -------------------------------------------------------------------

// IntQty32

// int32 mantissa = 1;
inline void IntQty32::clear_mantissa() {
  mantissa_ = 0;
}
inline ::google::protobuf::int32 IntQty32::mantissa() const {
  // @@protoc_insertion_point(field_get:Fix.IntQty32.mantissa)
  return mantissa_;
}
inline void IntQty32::set_mantissa(::google::protobuf::int32 value) {
  
  mantissa_ = value;
  // @@protoc_insertion_point(field_set:Fix.IntQty32.mantissa)
}

// uint32 exponent = 2;
inline void IntQty32::clear_exponent() {
  exponent_ = 0u;
}
inline ::google::protobuf::uint32 IntQty32::exponent() const {
  // @@protoc_insertion_point(field_get:Fix.IntQty32.exponent)
  return exponent_;
}
inline void IntQty32::set_exponent(::google::protobuf::uint32 value) {
  
  exponent_ = value;
  // @@protoc_insertion_point(field_set:Fix.IntQty32.exponent)
}

// -------------------------------------------------------------------

// NewOrderSingle

// uint64 transactTime = 1;
inline void NewOrderSingle::clear_transacttime() {
  transacttime_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 NewOrderSingle::transacttime() const {
  // @@protoc_insertion_point(field_get:Fix.NewOrderSingle.transactTime)
  return transacttime_;
}
inline void NewOrderSingle::set_transacttime(::google::protobuf::uint64 value) {
  
  transacttime_ = value;
  // @@protoc_insertion_point(field_set:Fix.NewOrderSingle.transactTime)
}

// .Fix.IntQty32 orderQty = 2;
inline bool NewOrderSingle::has_orderqty() const {
  return this != internal_default_instance() && orderqty_ != NULL;
}
inline void NewOrderSingle::clear_orderqty() {
  if (GetArenaNoVirtual() == NULL && orderqty_ != NULL) {
    delete orderqty_;
  }
  orderqty_ = NULL;
}
inline const ::Fix::IntQty32& NewOrderSingle::_internal_orderqty() const {
  return *orderqty_;
}
inline const ::Fix::IntQty32& NewOrderSingle::orderqty() const {
  const ::Fix::IntQty32* p = orderqty_;
  // @@protoc_insertion_point(field_get:Fix.NewOrderSingle.orderQty)
  return p != NULL ? *p : *reinterpret_cast<const ::Fix::IntQty32*>(
      &::Fix::_IntQty32_default_instance_);
}
inline ::Fix::IntQty32* NewOrderSingle::release_orderqty() {
  // @@protoc_insertion_point(field_release:Fix.NewOrderSingle.orderQty)
  
  ::Fix::IntQty32* temp = orderqty_;
  orderqty_ = NULL;
  return temp;
}
inline ::Fix::IntQty32* NewOrderSingle::mutable_orderqty() {
  
  if (orderqty_ == NULL) {
    auto* p = CreateMaybeMessage<::Fix::IntQty32>(GetArenaNoVirtual());
    orderqty_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Fix.NewOrderSingle.orderQty)
  return orderqty_;
}
inline void NewOrderSingle::set_allocated_orderqty(::Fix::IntQty32* orderqty) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete orderqty_;
  }
  if (orderqty) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      orderqty = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, orderqty, submessage_arena);
    }
    
  } else {
    
  }
  orderqty_ = orderqty;
  // @@protoc_insertion_point(field_set_allocated:Fix.NewOrderSingle.orderQty)
}

// .Fix.NewOrderSingle.OrdType ordType = 3;
inline void NewOrderSingle::clear_ordtype() {
  ordtype_ = 0;
}
inline ::Fix::NewOrderSingle_OrdType NewOrderSingle::ordtype() const {
  // @@protoc_insertion_point(field_get:Fix.NewOrderSingle.ordType)
  return static_cast< ::Fix::NewOrderSingle_OrdType >(ordtype_);
}
inline void NewOrderSingle::set_ordtype(::Fix::NewOrderSingle_OrdType value) {
  
  ordtype_ = value;
  // @@protoc_insertion_point(field_set:Fix.NewOrderSingle.ordType)
}

// .Fix.Decimal64 price = 4;
inline bool NewOrderSingle::has_price() const {
  return this != internal_default_instance() && price_ != NULL;
}
inline void NewOrderSingle::clear_price() {
  if (GetArenaNoVirtual() == NULL && price_ != NULL) {
    delete price_;
  }
  price_ = NULL;
}
inline const ::Fix::Decimal64& NewOrderSingle::_internal_price() const {
  return *price_;
}
inline const ::Fix::Decimal64& NewOrderSingle::price() const {
  const ::Fix::Decimal64* p = price_;
  // @@protoc_insertion_point(field_get:Fix.NewOrderSingle.price)
  return p != NULL ? *p : *reinterpret_cast<const ::Fix::Decimal64*>(
      &::Fix::_Decimal64_default_instance_);
}
inline ::Fix::Decimal64* NewOrderSingle::release_price() {
  // @@protoc_insertion_point(field_release:Fix.NewOrderSingle.price)
  
  ::Fix::Decimal64* temp = price_;
  price_ = NULL;
  return temp;
}
inline ::Fix::Decimal64* NewOrderSingle::mutable_price() {
  
  if (price_ == NULL) {
    auto* p = CreateMaybeMessage<::Fix::Decimal64>(GetArenaNoVirtual());
    price_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Fix.NewOrderSingle.price)
  return price_;
}
inline void NewOrderSingle::set_allocated_price(::Fix::Decimal64* price) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete price_;
  }
  if (price) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      price = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, price, submessage_arena);
    }
    
  } else {
    
  }
  price_ = price;
  // @@protoc_insertion_point(field_set_allocated:Fix.NewOrderSingle.price)
}

// .Fix.NewOrderSingle.Side side = 5;
inline void NewOrderSingle::clear_side() {
  side_ = 0;
}
inline ::Fix::NewOrderSingle_Side NewOrderSingle::side() const {
  // @@protoc_insertion_point(field_get:Fix.NewOrderSingle.side)
  return static_cast< ::Fix::NewOrderSingle_Side >(side_);
}
inline void NewOrderSingle::set_side(::Fix::NewOrderSingle_Side value) {
  
  side_ = value;
  // @@protoc_insertion_point(field_set:Fix.NewOrderSingle.side)
}

// .Fix.NewOrderSingle.TimeInForce tif = 6;
inline void NewOrderSingle::clear_tif() {
  tif_ = 0;
}
inline ::Fix::NewOrderSingle_TimeInForce NewOrderSingle::tif() const {
  // @@protoc_insertion_point(field_get:Fix.NewOrderSingle.tif)
  return static_cast< ::Fix::NewOrderSingle_TimeInForce >(tif_);
}
inline void NewOrderSingle::set_tif(::Fix::NewOrderSingle_TimeInForce value) {
  
  tif_ = value;
  // @@protoc_insertion_point(field_set:Fix.NewOrderSingle.tif)
}

// .Fix.NewOrderSingle.HandInst handInst = 7;
inline void NewOrderSingle::clear_handinst() {
  handinst_ = 0;
}
inline ::Fix::NewOrderSingle_HandInst NewOrderSingle::handinst() const {
  // @@protoc_insertion_point(field_get:Fix.NewOrderSingle.handInst)
  return static_cast< ::Fix::NewOrderSingle_HandInst >(handinst_);
}
inline void NewOrderSingle::set_handinst(::Fix::NewOrderSingle_HandInst value) {
  
  handinst_ = value;
  // @@protoc_insertion_point(field_set:Fix.NewOrderSingle.handInst)
}

// bytes symbol = 8;
inline void NewOrderSingle::clear_symbol() {
  symbol_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NewOrderSingle::symbol() const {
  // @@protoc_insertion_point(field_get:Fix.NewOrderSingle.symbol)
  return symbol_.GetNoArena();
}
inline void NewOrderSingle::set_symbol(const ::std::string& value) {
  
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Fix.NewOrderSingle.symbol)
}
#if LANG_CXX11
inline void NewOrderSingle::set_symbol(::std::string&& value) {
  
  symbol_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Fix.NewOrderSingle.symbol)
}
#endif
inline void NewOrderSingle::set_symbol(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Fix.NewOrderSingle.symbol)
}
inline void NewOrderSingle::set_symbol(const void* value, size_t size) {
  
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Fix.NewOrderSingle.symbol)
}
inline ::std::string* NewOrderSingle::mutable_symbol() {
  
  // @@protoc_insertion_point(field_mutable:Fix.NewOrderSingle.symbol)
  return symbol_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewOrderSingle::release_symbol() {
  // @@protoc_insertion_point(field_release:Fix.NewOrderSingle.symbol)
  
  return symbol_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewOrderSingle::set_allocated_symbol(::std::string* symbol) {
  if (symbol != NULL) {
    
  } else {
    
  }
  symbol_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), symbol);
  // @@protoc_insertion_point(field_set_allocated:Fix.NewOrderSingle.symbol)
}

// bytes account = 9;
inline void NewOrderSingle::clear_account() {
  account_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NewOrderSingle::account() const {
  // @@protoc_insertion_point(field_get:Fix.NewOrderSingle.account)
  return account_.GetNoArena();
}
inline void NewOrderSingle::set_account(const ::std::string& value) {
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Fix.NewOrderSingle.account)
}
#if LANG_CXX11
inline void NewOrderSingle::set_account(::std::string&& value) {
  
  account_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Fix.NewOrderSingle.account)
}
#endif
inline void NewOrderSingle::set_account(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Fix.NewOrderSingle.account)
}
inline void NewOrderSingle::set_account(const void* value, size_t size) {
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Fix.NewOrderSingle.account)
}
inline ::std::string* NewOrderSingle::mutable_account() {
  
  // @@protoc_insertion_point(field_mutable:Fix.NewOrderSingle.account)
  return account_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewOrderSingle::release_account() {
  // @@protoc_insertion_point(field_release:Fix.NewOrderSingle.account)
  
  return account_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewOrderSingle::set_allocated_account(::std::string* account) {
  if (account != NULL) {
    
  } else {
    
  }
  account_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account);
  // @@protoc_insertion_point(field_set_allocated:Fix.NewOrderSingle.account)
}

// bytes clOrdID = 10;
inline void NewOrderSingle::clear_clordid() {
  clordid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NewOrderSingle::clordid() const {
  // @@protoc_insertion_point(field_get:Fix.NewOrderSingle.clOrdID)
  return clordid_.GetNoArena();
}
inline void NewOrderSingle::set_clordid(const ::std::string& value) {
  
  clordid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Fix.NewOrderSingle.clOrdID)
}
#if LANG_CXX11
inline void NewOrderSingle::set_clordid(::std::string&& value) {
  
  clordid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Fix.NewOrderSingle.clOrdID)
}
#endif
inline void NewOrderSingle::set_clordid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  clordid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Fix.NewOrderSingle.clOrdID)
}
inline void NewOrderSingle::set_clordid(const void* value, size_t size) {
  
  clordid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Fix.NewOrderSingle.clOrdID)
}
inline ::std::string* NewOrderSingle::mutable_clordid() {
  
  // @@protoc_insertion_point(field_mutable:Fix.NewOrderSingle.clOrdID)
  return clordid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewOrderSingle::release_clordid() {
  // @@protoc_insertion_point(field_release:Fix.NewOrderSingle.clOrdID)
  
  return clordid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewOrderSingle::set_allocated_clordid(::std::string* clordid) {
  if (clordid != NULL) {
    
  } else {
    
  }
  clordid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clordid);
  // @@protoc_insertion_point(field_set_allocated:Fix.NewOrderSingle.clOrdID)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Fix

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Fix::NewOrderSingle_OrdType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Fix::NewOrderSingle_OrdType>() {
  return ::Fix::NewOrderSingle_OrdType_descriptor();
}
template <> struct is_proto_enum< ::Fix::NewOrderSingle_TimeInForce> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Fix::NewOrderSingle_TimeInForce>() {
  return ::Fix::NewOrderSingle_TimeInForce_descriptor();
}
template <> struct is_proto_enum< ::Fix::NewOrderSingle_Side> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Fix::NewOrderSingle_Side>() {
  return ::Fix::NewOrderSingle_Side_descriptor();
}
template <> struct is_proto_enum< ::Fix::NewOrderSingle_HandInst> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Fix::NewOrderSingle_HandInst>() {
  return ::Fix::NewOrderSingle_HandInst_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_fix_2dmessages_2eproto
